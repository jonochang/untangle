# Why Untangle

Software teams grow by shipping faster, safely. The problem is that speed often creates invisible structural debt: new imports, tighter coupling, and creeping cycles that make every change harder.

Untangle exists to make that invisible complexity visible, so teams can grow software while managing complexity instead of reacting to it later.

## The Core Problems

- **Coupling grows quietly.** A few extra dependencies per pull request add up to a brittle core.
- **Cycles are expensive.** Once circular dependencies appear, refactors get harder and riskier.
- **Architecture drift is slow-motion.** The graph changes long before humans feel the pain.

## What Untangle Changes

- **Objective guardrails.** CI can block structural regressions before they become habits.
- **Clear hotspots.** You can see which modules drive fan-out, entropy, and depth.
- **Shared language.** The team can talk about architecture with concrete metrics, not opinions.

## For Growing Teams

As teams and codebases scale, coordination cost rises faster than feature velocity. Untangle gives you a lightweight way to keep architecture understandable, so new engineers can move quickly without adding hidden complexity.

The result is a healthier dependency graph, steadier delivery, and fewer “surprise refactor” moments.
